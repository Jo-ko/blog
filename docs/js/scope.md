---
title: 作用域&执行上下文
date: 2020-04-29
tags:
- JS
categories:
- 前端知识
---

> 上下文决定了当前环境能够访问到哪些数据以及访问他们的行为方式

## 上下文保存的信息
1. 变量对象(活动对象): 当前上下文的变量和函数(包括arguments对象)
2. 作用域链: 决定各级上下文访问变量和函数的顺序(当前栈始终在作用域链的最前端)
3. this指针对象: 

## 变量提升
1. js引擎在解析代码的时候会把变量声明放到当前作用域的顶部,俗称作用域提升 
2. 与var不同的是let和const由于 __暂时性死区__ 的缘故,无法在显式声明之前被访问
3. __函数声明__ 会把整个函数提升至当前作用域的顶部

::: tip 暂时性死区
指的是在新的作用域进行实例化的时候,let/const声明的变量会先在作用域被创建,但此时还未进行词法绑定,是无法访问的
:::

::: tip 函数优先
函数声明和变量声明都会造成变量提升,但是函数声明会优先提升,然后是变量声明,但是变量声明不会覆盖之前同名的函数声明
```js
foo(); // 1
var foo;
function foo() { console.log( 1 );
}
foo = function() { console.log( 2 );
};
```
:::

## 全局作用域赋值
var如果在全局作用域环境定义会被赋值在全局对象上,而let和const则不会

## const优化
由于const的不可变性,JS引擎会在编译的阶段替换变量为实际值,以此来优化查找速度

## 作用域嵌套查询
沿着作用域链从当前作用域不断向上查找变量标识符,变量层级越高,消耗的性能越大

## 词法作用域
1. 作用域的类型有 __词法作用域(静态作用域)__ 和 __动态作用域__ 两种类型, JS属于词法作用域
2. 词法作用域简单的讲就是定义在词法阶段的作用域
3. 通过一些手法可以达到欺骗词法作用域的目的
   1. eval: eval生成的动态脚本作用域由他执行当前作用域环境决定
   2. with: with通过修改当前作用域的属性的引用对象来改变变量读取的内容

::: tip 词法作用域类型
1. 全局作用域
2. 函数作用域
3. 针对let和const还有块级作用域
:::

## 闭包
> 当函数可以记住并访问所在的词法作用域, 即使函数是在当前词法作用域之外执行，这时就产生了闭包。
```js
var fn;

function foo() {
   var a = 2;

   function baz() {
      console.log(a);
   }

   fn = baz; // 将 baz 分配给全局变量 
}
   function bar() {
      fn();
   }

   foo();
   bar(); // 2
```
### 闭包的作用
1. 限制变量的访问权限,定义私有属性
2. 避免全局变量污染,实现模块化

### 闭包的危害
由于闭包造成的作用域变量无法被垃圾回收机制所回收, 会导致内存占用过大

### 闭包的实质
**先看下一段函数执行的过程**
1. 首先JS引擎会对js先进行预编译,然后才是从上倒下开始执行过程
2. 在预编译的过程: 
   1. 代码解析; 
   2. 生成作用域链属性,将上层变量对象(VO)保存在[[Scope]]属性; 
   3. 初始化this对象;
3. 在执行的过程: 
   1. 压栈执行; 
   2. 生成当前环境的执行上下文对象;
   3. 复制[[Scope]]属性创建作用域链; 
   4. 创建当前变量对象(活动对象AO), 将其放入作用域链顶端;
   5. 确定this对象

**因此我们知道,当我们把一个函数返回给外层的某一个对象的时候,其函数仍然保存着对上层变量对象的引用, 因此垃圾回收机制无法回收上层变量对象**

::: tip VO & AO & GO
VO: __表示当前上下文中的所有变量__, VO涵盖AO, 当VO在全局执行上下文时, 也表示全局对象
AO: __私有变量对象(也叫活动对象)__, AO更侧重在函数执行上下文创建的变量
GO: __全局对象__, GO表示的是宿主环境下的globalThis属性(window,global) 

**VO**
- 对于var声明的变量来说
  - 在全局执行上下文中, VO具体的表现和GO一致, 因为所有创建的变量都会映射给全局变量GO, VO可以理解为等于GO
  - 在函数执行上下文中, VO就是AO
- 对于let/const声明的变量来说
  - VO不会把这部分映射给GO,因此此时的VO是包含GO但不等于GO
  - 此时全局声明的let/const,是无法通过globalThis获取的

**GO**
与VO和AO没有关机,是预定义的宿主环境对象,也是整个作用域链最外层的对象
:::
