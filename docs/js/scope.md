---
title: 作用域&执行上下文
date: 2020-04-29
tags:
- JS
categories:
- 前端知识
---

> 上下文决定了当前环境能够访问到哪些数据以及访问他们的行为方式

## 上下文保存的信息
1. 活动对象: 当前上下文的变量和函数(包括arguments对象)
   1. 变量环境: 通过var声明或function(){}声明的变量
   2. 词法环境: 通过const,let, with, trycatch创建的变量
2. 作用域链: 决定各级上下文访问变量和函数的顺序(当前栈始终在作用域链的最前端)
3. this指针对象: 

## 变量提升
1. 实质是一段JS在经过编译器编译之后,会被分为 __可执行代码__ 和 __执行上下文__
2. 与var不同的是let和const由于 __暂时性死区__ 的缘故,无法在显式声明之前被访问
3. __函数声明__ 会把整个函数提升至当前作用域的顶部

<img :src="$withBase('/js/variableAscension.png')" alt="variableAscension">

::: 如何同时做到变量提升和块级作用域
先查找词法环境中的变量栈, 没找到再查询变量环境
<img :src="$withBase('/js/lexicalEnvironment.png')" alt="lexicalEnvironment">
:::

::: tip 暂时性死区
指的是在新的作用域进行实例化的时候,let/const声明的变量会先在作用域被创建,但此时还未进行词法绑定,是无法访问的
:::

::: tip 函数优先
函数声明和变量声明都会造成变量提升,但是函数声明会优先提升,然后是变量声明,但是变量声明不会覆盖之前同名的函数声明
```js
foo(); // 1
var foo;
function foo() { console.log( 1 );
}
foo = function() { console.log( 2 );
};
```
:::

## 全局作用域赋值
var如果在全局作用域环境定义会被赋值在全局对象上,而let和const则不会

## const优化
由于const的不可变性,JS引擎会在编译的阶段替换变量为实际值,以此来优化查找速度

## 作用域嵌套查询
沿着作用域链从当前作用域不断向上查找变量标识符,变量层级越高,消耗的性能越大

## 词法作用域
1. 作用域的类型有 __词法作用域(静态作用域)__ 和 __动态作用域__ 两种类型, JS属于词法作用域
2. 词法作用域简单的讲就是定义在词法阶段的作用域
3. 通过一些手法可以达到欺骗词法作用域的目的
   1. eval: eval生成的动态脚本作用域由他执行当前作用域环境决定
   2. with: with通过修改当前作用域的属性的引用对象来改变变量读取的内容

::: tip 词法作用域类型
1. 全局作用域
2. 函数作用域
3. 针对let和const还有块级作用域
:::

## 闭包
> 内部函数总是可以访问到外部函数的变量环境,当外部函数返回内部函数的时候,即使外部函数已经出栈,但外部函数的变量仍保存在内存中,而这些变量的集合就成为闭包

```js
var fn;

function foo() {
   var a = 2;

   function baz() {
      console.log(a);
   }

   fn = baz; // 将 baz 分配给全局变量 
}
   function bar() {
      fn();
   }

   foo();
   bar(); // 2
```
### 闭包的作用
1. 限制变量的访问权限,定义私有属性
2. 避免全局变量污染,实现模块化

### 闭包的危害
由于闭包造成的作用域变量无法被垃圾回收机制所回收, 会导致内存占用过大

### 闭包的实质
**先看下一段函数执行的过程**
```javascript
function outer() {
    var name = 'outer';
    const sign = 0b01;
    return function inner() {
        console.log(name);
    }
}
const inner = outer();
inner();
```
1. 执行到outer()时候,会对outer进行预编译,进行变量提升,生成执行上下文栈环境
   1. 对于var声明的变量会放到变量环境中, const声明的变量放到词法环境中(暂时性死区), 这两个环境都存在执行上下文栈中
   2. 遇到inner函数,会进行提升,同时预扫描函数内部,进行词法扫描,发现引用name变量,此时会把name变量从栈移到堆内存的闭包集合中
   3. 在outer的变量环境中生成 __clourse(outer)__ 的变量属性,并将上面的闭包地址赋值给该变量
2. 开始执行代码,当返回inner函数的时候,outer整个栈环境会被回收,除了clourse(outer)所对应的堆内存仍会被inner函数引用,不会被回收

**因此我们知道,当我们把一个函数返回给外层的某一个对象的时候,其函数仍然保存着对上层变量对象的引用, 因此垃圾回收机制无法回收上层变量对象**

::: tip VO & AO & GO
VO: __表示当前上下文中的所有变量__, VO涵盖AO, 当VO在全局执行上下文时, 也表示全局对象
AO: __私有变量对象(也叫活动对象)__, AO更侧重在函数执行上下文创建的变量
GO: __全局对象__, GO表示的是宿主环境下的globalThis属性(window,global) 

**VO**
- 对于var声明的变量来说
  - 在全局执行上下文中, VO具体的表现和GO一致, 因为所有创建的变量都会映射给全局变量GO, VO可以理解为等于GO
  - 在函数执行上下文中, VO就是AO
- 对于let/const声明的变量来说
  - VO不会把这部分映射给GO,因此此时的VO是包含GO但不等于GO
  - 此时全局声明的let/const,是无法通过globalThis获取的

**GO**
与VO和AO没有关机,是预定义的宿主环境对象,也是整个作用域链最外层的对象
:::
